<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>


<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>HP 16500C Notes</title></head><body>
<div style="text-align: center;">
<h1>HP 16500C Notes</h1>
</div><font size="-2"><span style="font-weight: bold;">This file is part of OpenGPIB.</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;For details, see http://opengpib.sourceforge.net</span><br style="font-weight: bold;">
<br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;Copyright (C) 2008-2009 Doug Springer &lt;gpib a t rickyrockrat d o t net&gt;</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp; </span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; OpenGPIB is free software: you can redistribute it and/or modify</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; it under the terms of the GNU General Public License version 3 </span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; as published by the Free Software Foundation. Note that permission </span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; is not granted to redistribute this program under the terms of any</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; other version of the General Public License.</span><br style="font-weight: bold;">
<br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; OpenGPIB is distributed in the hope that it will be useful,</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; GNU General Public License for more details.</span><br style="font-weight: bold;">
<br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; You should have received a copy of the GNU General Public License</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; along with OpenGPIB.&nbsp; If not, see &lt;http://www.gnu.org/licenses/&gt;.</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; </span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; The License should be in the file called COPYING.</span></font><br>
<br>
<br>
The HP16500C manuals do not describe the configuration data stream.
These notes describe some of the reverse-engineering done to figure out
the fields in the configuration data returned from the :SYSTEM:SETUP?<br>command.<br><br>The data stream begins as a block (as described in the programming manual). Here is an example file dump of the <span style="font-weight: bold;">start</span> of the config file. Sections are cut out that are not yet decoded.<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp; 1&nbsp; 2&nbsp; 3&nbsp;&nbsp; 4&nbsp; 5&nbsp; 6&nbsp;
7&nbsp;&nbsp; 8&nbsp; 9&nbsp; A&nbsp; B&nbsp;&nbsp; C&nbsp; D&nbsp;
E&nbsp; F<br>00000000&nbsp; 23 38 30 30&nbsp; 32 32 30 31&nbsp; 36 30 43 4f&nbsp; 4e 46 49 47&nbsp;&nbsp; #800220160CONFIG<br>00000010&nbsp;
20 20 20 20&nbsp; 02 22 00 00&nbsp; 80 c8 4d 41&nbsp; 43 48 49
4e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ."....MACHIN<br>00000020&nbsp; 45 20 31 20&nbsp; 00 00 00 00&nbsp; 00 01 00 00&nbsp; 00 00 00 00&nbsp;&nbsp; E 1 ............<br>00000030&nbsp; 00 00 00 00&nbsp; 00 02 ff ff&nbsp; ff ff 00 20&nbsp; 00 06 00 20&nbsp;&nbsp; ........... ... <br>00000040&nbsp; 00 06 00 66&nbsp; 00 00 00 2a&nbsp; aa aa ff ff&nbsp; ff ff ff ff&nbsp;&nbsp; ...f...*........<br>00000050&nbsp; ff ff ff ff&nbsp; ff ff ff ff&nbsp; ff ff 4d 41&nbsp; 43 48 49 4e&nbsp;&nbsp; ..........MACHIN<br>00000060&nbsp; 45 20 32 20&nbsp; 00 00 00 00&nbsp; 00 00 00 00&nbsp; 00 00 00 00&nbsp;&nbsp; E 2 ............<br>00000070&nbsp; 00 00 00 00&nbsp; 00 02 ff ff&nbsp; ff ff 00 20&nbsp; 00 18 00 20&nbsp;&nbsp; ........... ... <br>00000080&nbsp; 00 18 00 78&nbsp; 00 00 00 2a&nbsp; aa aa ff ff&nbsp; ff ff ff ff&nbsp;&nbsp; ...x...*........<br>00000090&nbsp; ff ff ff ff&nbsp; ff ff ff ff&nbsp; ff ff 00 00&nbsp; 00 04 00 1f&nbsp;&nbsp; ................<br>000000a0&nbsp; ff e0 00 00&nbsp; 00 00 00 00&nbsp; 00 00 00 00&nbsp; 00 00 00 00&nbsp;&nbsp; ................<br><br>00000270&nbsp; ff ff 00 00&nbsp; 00 00 00 00&nbsp; 00 00 00 00&nbsp; 01 4a ff ff&nbsp;&nbsp; .............J..<br>00000280&nbsp; ff ff 00 00&nbsp; 00 00 00 00&nbsp; 00 00 00 00&nbsp; 00 64 ff ff&nbsp;&nbsp; .............d..<br>00000290&nbsp; ff ff 00 00&nbsp; 43 4c 4b 20&nbsp; 20 20 00 00&nbsp; 00 00 00 af&nbsp;&nbsp; ....CLK&nbsp;&nbsp; ......<br>000002a0&nbsp; df 30 00 00&nbsp; 00 00 01 01&nbsp; 01 37 44 49&nbsp; 4f 31 20 20&nbsp;&nbsp; .0.......7DIO1&nbsp; <br>000002b0&nbsp; 00 00 00 01&nbsp; 00 af df 3c&nbsp; 00 00 00 00&nbsp; 01 01 02 37&nbsp;&nbsp; .......&lt;.......7<br>000002c0&nbsp; 44 49 4f 32&nbsp; 20 20 00 00&nbsp; 00 01 00 af&nbsp; df 48 00 00&nbsp;&nbsp; DIO2&nbsp; .......H..<br>000002d0&nbsp; 00 00 01 01&nbsp; 03 37 52 2f&nbsp; 4c 20 20 20&nbsp; 00 00 00 01&nbsp;&nbsp; .....7R/L&nbsp;&nbsp; ....<br>000002e0&nbsp; 00 af df 54&nbsp; 00 00 00 00&nbsp; 01 00 04 37&nbsp; 50 4f 4c 20&nbsp;&nbsp; ...T.......7POL <br>000002f0&nbsp; 20 20 00 00&nbsp; 00 01 00 af&nbsp; df 60 00 00&nbsp; 00 00 01 01&nbsp;&nbsp;&nbsp;&nbsp; .......`......<br>00000300&nbsp; 05 37 4c 44&nbsp; 20 20 20 20&nbsp; 00 00 00 01&nbsp; 00 af df 6c&nbsp;&nbsp; .7LD&nbsp;&nbsp;&nbsp; .......l<br>00000310&nbsp; 00 00 00 00&nbsp; 01 01 06 37&nbsp; 30 45 20 20&nbsp; 20 20 00 00&nbsp;&nbsp; .......70E&nbsp;&nbsp;&nbsp; .. </code><br><br>Looking at the dump above, you can clearly see the two machine names, so that's pretty obvious. &nbsp;<br>Byte 29 tells us this machine 1 is in timing mode. &nbsp;Byte 31 tells us we are using full channel mode.<br>For
some reason, the pod assignment map (3D, 41, and 43) is
duplicated&nbsp;places (at least in the timing mode I tested). It tells
us pod 1/2 is assigned to machine 1. You'll note that machine 2 has pod
3/4 assigned to it, but since it is off, the point is moot.<br><br>Here is the C structure for the two machine entries above:<br><br><code>#define POD_INFO_A1 0x02<br>#define POD_INFO_A2 0x04<br>#define POD_INFO_A3 0x08<br>#define POD_INFO_A4 0x10<br>/**10 bytes&nbsp; */<br>struct pod_assignment {<br>&nbsp;&nbsp;&nbsp; uint8 unknown1[3];<br>&nbsp;&nbsp;&nbsp; uint8 pod_info0; /**pod_info0 and 1 always seem to be equal to each other No pods=0 */<br>&nbsp;&nbsp;&nbsp; uint8 unknown2[3];<br>&nbsp;&nbsp;&nbsp; uint8 pod_info1;<br>&nbsp;&nbsp;&nbsp; uint8 unknown3;<br>&nbsp;&nbsp;&nbsp;
uint8 pod_info2; /**this is 0x06 with no pods assigned to either
analyzer, 0x66 if pod1/2, 0x78 if pod 3/4, 0x1E if pod1,2,3,4.&nbsp; */<br>}__attribute__((__packed__));&nbsp;&nbsp;&nbsp; <br>/**defines for the mode byte below&nbsp; */<br>#define MACHINE_MODE_OFF &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 0<br>#define MACHINE_MODE_TIMING 1<br>#define MACHINE_MODE_STATE&nbsp;&nbsp;&nbsp; 2<br>#define MACHINE_MODE_CMP_SPA 3<br>/*defines for mode2 below */<br>#define MACHINE_MODE2_FULL 0<br>#define MACHINE_MODE2_HALF 1<br>/*64 bytes per machine config*/<br><br>struct machine_config {<br>&nbsp;&nbsp;&nbsp; char name[11];<br>&nbsp;&nbsp;&nbsp; uint8 unknown3[4];<br>&nbsp;&nbsp;&nbsp; uint8 mode;&nbsp;&nbsp;&nbsp; /**0=off,1=timing,2=state,3=statecompare or SPA&nbsp; */<br>&nbsp;&nbsp;&nbsp; uint8 unknown4[7];<br>&nbsp;&nbsp;&nbsp; uint8 mode2;&nbsp;&nbsp;&nbsp; &nbsp;/*0=fullchannel, 1=half channel*/<br>&nbsp;&nbsp;&nbsp; uint8 unknown5[8];<br>&nbsp;&nbsp;&nbsp; struct pod_assignment assign;<br>&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp; un[22];<br>}__attribute__((__packed__));&nbsp;&nbsp;&nbsp; </code><br><br><br>The label sections begin at 294. If you look at just this section (22 bytes per line):<br><br><code>43 4C 4B 20 20 20 00 00 00 00 00 AF DF 30 00 00 00 00 01 01 01 37 <br>44 49 4F 31 20 20 00 00 00 01 00 AF DF 3C 00 00 00 00 01 01 02 37</code><br>|Label
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;
&nbsp; B P &nbsp; &nbsp; &nbsp; ADDR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; B &nbsp;E &nbsp;S<br><br>&nbsp;You will see that it starts with a label name that is always 6 bytes. The above above bits are as follows:<br>B=#bits (lines) for this signal - it seems to be repeated twice, so I assume one means something else.<br>E=enabled<br>S=Sequence #<br>ADDR
is an offset further into the code to the bit positions. After *much*
scrounging about, I came up with this formula: Take the address here
(i.e. AFDF30) subtract AF6BFC from it and you get the real absolute
(i.e. beginning of file) offset.<br><br>At this address you will find the following bit fields<br><br><code>00 00 00 00 00 00 00 00 00 00 00 00</code><br>?J ?? H4L &nbsp;H3L H2L &nbsp;H1L ????<br><br>Decoding, I suspect the top 2 bytes are the clock. The J is for J Clock. The H4L means High byte Low byte for pod 4. <br><br>Here are the C structures &nbsp;and defines for this:<br><br><br><code>#define LABEL_RECORD_LEN 22<br>#define LABEL_MAP_LEN 12<br>#define POD_ARRAYSIZE 10<br><br>struct label_map {<br>&nbsp;&nbsp;&nbsp; /**offset 0= hi byte.&nbsp; */<br>&nbsp;&nbsp;&nbsp; uint8 clk_pods[POD_ARRAYSIZE]; /**0 and 1 index are clk, 2 idx is hi byte of pod4&nbsp; */<br>&nbsp;&nbsp;&nbsp; uint8 unknown;<br>}__attribute__((__packed__));&nbsp;&nbsp;&nbsp; <br><br>T<br>struct labels {<br>&nbsp;&nbsp;&nbsp; char name[6];<br>&nbsp;&nbsp;&nbsp; uint8 unknown1[3];<br>&nbsp;&nbsp;&nbsp; uint8 polarity;<br>&nbsp;&nbsp;&nbsp; uint8 unknown2;<br>&nbsp;&nbsp;&nbsp; uint8 strange_offset;<br>&nbsp;&nbsp;&nbsp; uint16 strange_offsetlo;<br>&nbsp;&nbsp;&nbsp; uint8 unknown3[4];<br>&nbsp;&nbsp;&nbsp; uint8 bits;<br>&nbsp;&nbsp;&nbsp; uint8 enable;<br>&nbsp;&nbsp;&nbsp; uint8 sequence;<br>&nbsp;&nbsp;&nbsp; uint32 actual_offset;<br>&nbsp;&nbsp;&nbsp; struct label_map map;<br>}__attribute__((__packed__));&nbsp;&nbsp;&nbsp; <br></code><br><br><br>&nbsp; &nbsp;<br><br>
</body></html>